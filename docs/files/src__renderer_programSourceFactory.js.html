<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/_renderer/programSourceFactory.js - xeoengine</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 style="color:white;"><a href="../../">xeoEngine</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
                                <li><a href="../classes/Billboard.html">Billboard</a></li>
                                <li><a href="../classes/Boundary2D.html">Boundary2D</a></li>
                                <li><a href="../classes/Boundary3D.html">Boundary3D</a></li>
                                <li><a href="../classes/BoundaryGeometry.html">BoundaryGeometry</a></li>
                                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
                                <li><a href="../classes/Camera.html">Camera</a></li>
                                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
                                <li><a href="../classes/CameraController.html">CameraController</a></li>
                                <li><a href="../classes/CameraFlight.html">CameraFlight</a></li>
                                <li><a href="../classes/Canvas.html">Canvas</a></li>
                                <li><a href="../classes/Clip.html">Clip</a></li>
                                <li><a href="../classes/Clips.html">Clips</a></li>
                                <li><a href="../classes/Collection.html">Collection</a></li>
                                <li><a href="../classes/CollectionBoundary.html">CollectionBoundary</a></li>
                                <li><a href="../classes/ColorBuf.html">ColorBuf</a></li>
                                <li><a href="../classes/ColorTarget.html">ColorTarget</a></li>
                                <li><a href="../classes/Component.html">Component</a></li>
                                <li><a href="../classes/Configs.html">Configs</a></li>
                                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
                                <li><a href="../classes/Cull.html">Cull</a></li>
                                <li><a href="../classes/Curve.html">Curve</a></li>
                                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
                                <li><a href="../classes/DepthBuf.html">DepthBuf</a></li>
                                <li><a href="../classes/DepthTarget.html">DepthTarget</a></li>
                                <li><a href="../classes/DirLight.html">DirLight</a></li>
                                <li><a href="../classes/Entity.html">Entity</a></li>
                                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/HeightmapGeometry.html">HeightmapGeometry</a></li>
                                <li><a href="../classes/Input.html">Input</a></li>
                                <li><a href="../classes/KeyboardAxisCamera.html">KeyboardAxisCamera</a></li>
                                <li><a href="../classes/KeyboardPanCamera.html">KeyboardPanCamera</a></li>
                                <li><a href="../classes/KeyboardRotateCamera.html">KeyboardRotateCamera</a></li>
                                <li><a href="../classes/KeyboardZoomCamera.html">KeyboardZoomCamera</a></li>
                                <li><a href="../classes/LatheGeometry.html">LatheGeometry</a></li>
                                <li><a href="../classes/Layer.html">Layer</a></li>
                                <li><a href="../classes/Lights.html">Lights</a></li>
                                <li><a href="../classes/Lookat.html">Lookat</a></li>
                                <li><a href="../classes/Material.html">Material</a></li>
                                <li><a href="../classes/MegaTexture.html">MegaTexture</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/Modes.html">Modes</a></li>
                                <li><a href="../classes/MorphTargets.html">MorphTargets</a></li>
                                <li><a href="../classes/MousePanCamera.html">MousePanCamera</a></li>
                                <li><a href="../classes/MousePickEntity.html">MousePickEntity</a></li>
                                <li><a href="../classes/MouseRotateCamera.html">MouseRotateCamera</a></li>
                                <li><a href="../classes/MouseZoomCamera.html">MouseZoomCamera</a></li>
                                <li><a href="../classes/Nintendo3DSGeometry.html">Nintendo3DSGeometry</a></li>
                                <li><a href="../classes/OBJGeometry.html">OBJGeometry</a></li>
                                <li><a href="../classes/Ortho.html">Ortho</a></li>
                                <li><a href="../classes/Path.html">Path</a></li>
                                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
                                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
                                <li><a href="../classes/PointLight.html">PointLight</a></li>
                                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
                                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
                                <li><a href="../classes/Reflect.html">Reflect</a></li>
                                <li><a href="../classes/Rotate.html">Rotate</a></li>
                                <li><a href="../classes/Scale.html">Scale</a></li>
                                <li><a href="../classes/Scene.html">Scene</a></li>
                                <li><a href="../classes/Shader.html">Shader</a></li>
                                <li><a href="../classes/ShaderParams.html">ShaderParams</a></li>
                                <li><a href="../classes/Skybox.html">Skybox</a></li>
                                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
                                <li><a href="../classes/Spinner.html">Spinner</a></li>
                                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
                                <li><a href="../classes/Stage.html">Stage</a></li>
                                <li><a href="../classes/Stationary.html">Stationary</a></li>
                                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
                                <li><a href="../classes/Texture.html">Texture</a></li>
                                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/Translate.html">Translate</a></li>
                                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
                                <li><a href="../classes/Viewport.html">Viewport</a></li>
                                <li><a href="../classes/Visibility.html">Visibility</a></li>
                                <li><a href="../classes/XEO.html">XEO</a></li>
                                <li><a href="../classes/XEO.math.math.html">XEO.math.math</a></li>
                                <li><a href="../classes/ZSpace.html">ZSpace</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="..//modules/animation.html">animation</a></li>
                                <li><a href="..//modules/boundaries.html">boundaries</a></li>
                                <li><a href="..//modules/camera.html">camera</a></li>
                                <li><a href="..//modules/canvas.html">canvas</a></li>
                                <li><a href="..//modules/clipping.html">clipping</a></li>
                                <li><a href="..//modules/collections.html">collections</a></li>
                                <li><a href="..//modules/configs.html">configs</a></li>
                                <li><a href="..//modules/controls.html">controls</a></li>
                                <li><a href="..//modules/culling.html">culling</a></li>
                                <li><a href="..//modules/curves.html">curves</a></li>
                                <li><a href="..//modules/entities.html">entities</a></li>
                                <li><a href="..//modules/geometry.html">geometry</a></li>
                                <li><a href="..//modules/importing.html">importing</a></li>
                                <li><a href="..//modules/input.html">input</a></li>
                                <li><a href="..//modules/interaction.html">interaction</a></li>
                                <li><a href="..//modules/lighting.html">lighting</a></li>
                                <li><a href="..//modules/materials.html">materials</a></li>
                                <li><a href="..//modules/math.html">math</a></li>
                                <li><a href="..//modules/paths.html">paths</a></li>
                                <li><a href="..//modules/rendering.html">rendering</a></li>
                                <li><a href="..//modules/shaders.html">shaders</a></li>
                                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
                                <li><a href="..//modules/transforms.html">transforms</a></li>
                                <li><a href="..//modules/webvr.html">webvr</a></li>
                                <li><a href="..//modules/XEO.html">XEO</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
                    <!--Show:-->
                    <!--<label for="api-show-inherited">-->
                        <!--<input type="checkbox" id="api-show-inherited" checked>-->
                        <!--Inherited-->
                    <!--</label>-->
            
                    <!--<label for="api-show-protected">-->
                        <!--<input type="checkbox" id="api-show-protected">-->
                        <!--Protected-->
                    <!--</label>-->
            
                    <!--<label for="api-show-private">-->
                        <!--<input type="checkbox" id="api-show-private">-->
                        <!--Private-->
                    <!--</label>-->
                    <!--<label for="api-show-deprecated">-->
                        <!--<input type="checkbox" id="api-show-deprecated">-->
                        <!--Deprecated-->
                    <!--</label>-->
            
                <!--</div>-->
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/_renderer/programSourceFactory.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function () {

    &quot;use strict&quot;;

    /**
     *  Manages creation, sharing and recycle of {@link XEO.renderer.ProgramSource} instances
     */
    XEO.renderer.ProgramSourceFactory = new (function () {

        var cache = {}; // Caches source code against hashes

        var src = &quot;&quot;; // Accumulates source code as it&#x27;s being built

        var states; // Cache rendering state
        var texturing; // True when rendering state contains textures
        var normals; // True when rendering state contains normals
        var normalMapping; // True when rendering state contains tangents
        var reflection; // True when rendering state contains reflections

        var diffuseFresnel;
        var specularFresnel;
        var opacityFresnel;
        var reflectivityFresnel;
        var emissiveFresnel;

        /**
         * Get source code for a program to render the given states.
         * Attempts to reuse cached source code for the given hash.
         */
        this.getSource = function (hash, _states) {

            var source = cache[hash];

            if (source) {
                source.useCount++;
                return source;
            }

            states = _states;

            texturing = hasTextures();
            normals = hasNormals();
            normalMapping = hasNormalMap();
            reflection = hasReflection();

            diffuseFresnel = states.material.diffuseFresnel;
            specularFresnel = states.material.specularFresnel;
            opacityFresnel = states.material.opacityFresnel;
            reflectivityFresnel = states.material.reflectivityFresnel;
            emissiveFresnel = states.material.emissiveFresnel;

            source = new XEO.renderer.ProgramSource(
                hash,
                vertexPickObject(),
                fragmentPickObject(),
                vertexPickPrimitive(),
                fragmentPickPrimitive(),
                vertexDraw(),
                fragmentDraw()
            );

            cache[hash] = source;

            return source;
        };

        function hasTextures() {
            if (!states.geometry.uv) {
                return false;
            }
            var material = states.material;
            return material.ambientMap ||
                material.diffuseMap ||
                material.specularMap ||
                material.emissiveMap ||
                material.opacityMap ||
                material.reflectivityMap ||
                states.material.normalMap;
        }

        function hasReflection() {
            return false;
            //return (states.cubemap.layers &amp;&amp; states.cubemap.layers.length &gt; 0 &amp;&amp; states.geometry.normalBuf);
        }

        function hasNormals() {
            var primitive = states.geometry.primitiveName;
            if (states.geometry.normals &amp;&amp; (primitive === &quot;triangles&quot; || primitive === &quot;triangle-strip&quot; || primitive === &quot;triangle-fan&quot;)) {
                return true;
            }
            return false;
        }

        function hasNormalMap() {
            var geometry = states.geometry;
            return (geometry.positions &amp;&amp; geometry.indices &amp;&amp; geometry.normals &amp;&amp; geometry.uv &amp;&amp; states.material.normalMap);
        }

        /**
         * Releases program source code back to this factory.
         */
        this.putSource = function (hash) {
            var source = cache[hash];
            if (source) {
                if (--source.useCount === 0) {
                    cache[source.hash] = null;
                }
            }
        };


        // NOTE: Picking shaders will become more complex and will eventually be
        // composed from state, in the same manner as the draw shaders.

        function vertexPickObject() {
            begin();
            add(&quot;// Object picking vertex shader&quot;);
            add(&quot;attribute vec3 xeo_aPosition;&quot;);
            add(&quot;uniform mat4 xeo_uModelMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uViewMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uViewNormalMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uProjMatrix;&quot;);
            add(&quot;varying vec4 xeo_vWorldPosition;&quot;);
            add(&quot;varying vec4 xeo_vViewPosition;&quot;);
            add(&quot;void main(void) {&quot;);
            add(&quot;   vec4 tmpVertex = vec4(xeo_aPosition, 1.0); &quot;);
            add(&quot;   xeo_vWorldPosition = xeo_uModelMatrix * tmpVertex; &quot;);
            add(&quot;   xeo_vViewPosition = xeo_uViewMatrix * xeo_vWorldPosition;&quot;);
            add(&quot;   gl_Position = xeo_uProjMatrix * xeo_vViewPosition;&quot;);
            add(&quot;}&quot;);
            return end();
        }

        function fragmentPickObject() {
            begin();
            add(&quot;// Object picking fragment shader&quot;);
            add(&quot;precision &quot; + getFSFloatPrecision(states._canvas.gl) + &quot; float;&quot;);
            add(&quot;uniform vec4 xeo_uPickColor;&quot;);
            add(&quot;void main(void) {&quot;);
            add(&quot;   gl_FragColor = xeo_uPickColor; &quot;);
            add(&quot;}&quot;);
            return end();
        }

        function vertexPickPrimitive() {
            begin();
            add(&quot;// Triangle picking vertex shader&quot;);
            add(&quot;attribute vec3 xeo_aPosition;&quot;);
            add(&quot;attribute vec4 xeo_aColor;&quot;);
            add(&quot;uniform vec3 xeo_uPickColor;&quot;);
            add(&quot;uniform mat4 xeo_uModelMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uViewMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uProjMatrix;&quot;);
            add(&quot;varying vec4 xeo_vWorldPosition;&quot;);
            add(&quot;varying vec4 xeo_vViewPosition;&quot;);
            add(&quot;varying vec4 xeo_vColor;&quot;);
            add(&quot;void main(void) {&quot;);
            add(&quot;   vec4 tmpVertex = vec4(xeo_aPosition, 1.0); &quot;);
            add(&quot;   vec4 worldPosition = xeo_uModelMatrix * tmpVertex; &quot;);
            add(&quot;   vec4 viewPosition = xeo_uViewMatrix * worldPosition;&quot;);
            add(&quot;   xeo_vColor = xeo_aColor;&quot;);
            add(&quot;   gl_Position = xeo_uProjMatrix * viewPosition;&quot;);
            add(&quot;}&quot;);
            return end();
        }

        function fragmentPickPrimitive() {
            begin();
            add(&quot;// Triangle picking fragment shader&quot;);
            add(&quot;precision &quot; + getFSFloatPrecision(states._canvas.gl) + &quot; float;&quot;);
            add(&quot;varying vec4 xeo_vColor;&quot;);
            add(&quot;void main(void) {&quot;);
            add(&quot;   gl_FragColor = xeo_vColor;&quot;);
            add(&quot;}&quot;);
            return end();
        }

        function vertexDraw() {

            var vertex = states.shader.vertex;

            if (vertex) {

                // Custom vertex shader
                return vertex;
            }

            var i;
            var len;
            var light;

            begin();

            add(&quot;// Drawing vertex shader&quot;);

            add(&quot;uniform mat4 xeo_uModelMatrix;          // Modeling matrix&quot;);
            add(&quot;uniform mat4 xeo_uViewMatrix;           // Viewing matrix&quot;);
            add(&quot;uniform mat4 xeo_uProjMatrix;           // Projection matrix&quot;);

            add(&quot;attribute vec3 xeo_aPosition;           // Local-space vertex position&quot;);

            add();

            add(&quot;varying vec4 xeo_vViewPosition;         // Output: View-space fragment position&quot;);

            if (normals) {

                add();

                add(&quot;attribute vec3 xeo_aNormal;             // Local-space vertex normal&quot;);

                add(&quot;uniform mat4 xeo_uModelNormalMatrix;    // Modeling normal matrix&quot;);
                add(&quot;uniform mat4 xeo_uViewNormalMatrix;     // Viewing normal matrix&quot;);

                add(&quot;varying vec3 xeo_vViewEyeVec;           // Output: View-space vector from fragment position to eye&quot;);
                add(&quot;varying vec3 xeo_vViewNormal;           // Output: View-space normal&quot;);

                // Lights
                for (i = 0, len = states.lights.lights.length; i &lt; len; i++) {

                    light = states.lights.lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    if (light.type === &quot;dir&quot;) {
                        add(&quot;uniform vec3 xeo_uLightDir&quot; + i + &quot;;   // Directional light direction&quot;);
                    }

                    if (light.type === &quot;point&quot;) {
                        add(&quot;uniform vec3 xeo_uLightPos&quot; + i + &quot;;   // Positional light position&quot;);
                    }

                    if (light.type === &quot;spot&quot;) {
                        add(&quot;uniform vec3 xeo_uLightPos&quot; + i + &quot;;   // Spot light position&quot;);
                    }

                    add(&quot;varying vec4 xeo_vViewLightVecAndDist&quot; + i + &quot;; // Output: Vector from vertex to light, packaged with the pre-computed length of that vector&quot;);
                }
            }

            if (normalMapping) {
                add(&quot;attribute vec3 xeo_aTangent;&quot;);
            }

            if (texturing) {

                add();

                // Vertex UV coordinate
                add(&quot;attribute vec2 xeo_aUV;&quot;);

                // Fragment UV coordinate
                add(&quot;varying vec2 xeo_vUV;&quot;);
            }

            if (states.geometry.colors) {

                // Vertex color
                add(&quot;attribute vec4 xeo_aColor;&quot;);

                // Fragment color
                add(&quot;varying vec4 xeo_vColor;&quot;);
            }

            if (states.geometry.primitiveName === &quot;points&quot;) {
                add(&quot;uniform float xeo_uPointSize;&quot;);
            }

            if (states.billboard.active) {

                add(&quot;void billboard(inout mat4 mat) {&quot;);
                add(&quot;   mat[0][0] = 1.0;&quot;);
                add(&quot;   mat[0][1] = 0.0;&quot;);
                add(&quot;   mat[0][2] = 0.0;&quot;);
                if (states.billboard.spherical) {
                    add(&quot;   mat[1][0] = 0.0;&quot;);
                    add(&quot;   mat[1][1] = 1.0;&quot;);
                    add(&quot;   mat[1][2] = 0.0;&quot;);
                }
                add(&quot;   mat[2][0] = 0.0;&quot;);
                add(&quot;   mat[2][1] = 0.0;&quot;);
                add(&quot;   mat[2][2] =1.0;&quot;);
                add(&quot;}&quot;);
            }

            // ------------------- main -------------------------------

            add();
            add(&quot;void main(void) {&quot;);
            add();
            add(&quot;   vec4 localPosition = vec4(xeo_aPosition, 1.0); &quot;);

            if (normals) {

                add(&quot;   vec4 localNormal = vec4(xeo_aNormal, 0.0); &quot;);
                add(&quot;   mat4 modelNormalMatrix = xeo_uModelNormalMatrix;&quot;);
                add(&quot;   mat4 viewNormalMatrix = xeo_uViewNormalMatrix;&quot;);
            }

            add(&quot;   mat4 modelMatrix = xeo_uModelMatrix;&quot;);
            add(&quot;   mat4 viewMatrix = xeo_uViewMatrix;&quot;);
            add(&quot;   vec4 worldPosition;&quot;);

            if (states.stationary.active) {
                add(&quot;   viewMatrix[3][0] = viewMatrix[3][1] = viewMatrix[3][2] = 0.0;&quot;)
            }

            if (states.billboard.active) {

                add(&quot;   mat4 modelViewMatrix =  xeo_uViewMatrix * xeo_uModelMatrix;&quot;);

                add(&quot;   billboard(modelMatrix);&quot;);
                add(&quot;   billboard(viewMatrix);&quot;);
                add(&quot;   billboard(modelViewMatrix);&quot;);

                if (normals) {

                    add(&quot;   mat4 modelViewNormalMatrix =  xeo_uViewNormalMatrix * xeo_uModelNormalMatrix;&quot;);

                    add(&quot;   billboard(modelNormalMatrix);&quot;);
                    add(&quot;   billboard(viewNormalMatrix);&quot;);
                    add(&quot;   billboard(modelViewNormalMatrix);&quot;);
                }

                add(&quot;   worldPosition = modelMatrix * localPosition;&quot;);
                add(&quot;   vec4 viewPosition = modelViewMatrix * localPosition;&quot;);

            } else {

                add(&quot;   worldPosition = modelMatrix * localPosition;&quot;);
                add(&quot;   vec4 viewPosition  = viewMatrix * worldPosition; &quot;);
            }

            if (normals) {

                add(&quot;   vec3 worldNormal = (modelNormalMatrix * localNormal).xyz; &quot;);
                add(&quot;   xeo_vViewNormal = normalize((viewNormalMatrix * vec4(worldNormal, 1.0)).xyz);&quot;);

                if (normalMapping) {

                    // Compute the tangent-bitangent-normal (TBN) matrix

                    add(&quot;   vec3 tangent = normalize((xeo_uViewNormalMatrix * xeo_uModelNormalMatrix * vec4(xeo_aTangent, 1.0)).xyz);&quot;);
                    add(&quot;   vec3 bitangent = cross(xeo_vViewNormal, tangent);&quot;);
                    add(&quot;   mat3 TBN = mat3(tangent, bitangent, xeo_vViewNormal);&quot;);
                }

                add(&quot;   vec3 tmpVec3;&quot;);
                add(&quot;   float lightDist;&quot;);

                // Lights

                for (i = 0, len = states.lights.lights.length; i &lt; len; i++) {

                    light = states.lights.lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    if (light.type === &quot;dir&quot;) {

                        // Directional light

                        if (light.space === &quot;world&quot;) {

                            // World space light

                            add(&quot;   tmpVec3 = xeo_uLightDir&quot; + i + &quot;;&quot;);

                            // Transform to View space
                            add(&quot;   tmpVec3 = vec3(viewMatrix * vec4(tmpVec3, 1.0)).xyz;&quot;);

                            if (normalMapping) {

                                // Transform to Tangent space
                                add(&quot;   tmpVec3 *= TBN;&quot;);
                            }

                        } else {

                            // View space light

                            add(&quot;   tmpVec3 = xeo_uLightDir&quot; + i + &quot;;&quot;);

                            if (normalMapping) {

                                // Transform to Tangent space
                                add(&quot;   tmpVec3 *= TBN;&quot;);
                            }
                        }

                        // Pipe the light direction and zero distance through to the fragment shader
                        add(&quot;   xeo_vViewLightVecAndDist&quot; + i + &quot; = vec4(tmpVec3, 0.0);&quot;);
                    }

                    if (light.type === &quot;point&quot;) {

                        // Positional light

                        if (light.space === &quot;world&quot;) {

                            // World space

                            // Get vertex -&gt; light vector in View space
                            // Transform light pos to View space first
                            add(&quot;   tmpVec3 = (viewMatrix * vec4(xeo_uLightPos&quot; + i + &quot;, 1.0)).xyz - viewPosition.xyz;&quot;); // Vector from World coordinate to light pos

                            // Get distance to light
                            add(&quot;   lightDist = abs(length(tmpVec3));&quot;);

                            if (normalMapping) {

                                // Transform light vector to Tangent space
                               add(&quot;   tmpVec3 *= TBN;&quot;);
                            }

                        } else {

                            // View space

                            // Get vertex -&gt; light vector in View space
                            add(&quot;   tmpVec3 = xeo_uLightPos&quot; + i + &quot;.xyz - viewPosition.xyz;&quot;); // Vector from View coordinate to light pos

                            // Get distance to light
                            add(&quot;   lightDist = abs(length(tmpVec3));&quot;);

                            if (normalMapping) {

                                // Transform light vector to tangent space
                                add(&quot;   tmpVec3 *= TBN;&quot;);
                            }
                        }

                        // Pipe the light direction and distance through to the fragment shader
                        add(&quot;   xeo_vViewLightVecAndDist&quot; + i + &quot; = vec4(tmpVec3, lightDist);&quot;);
                    }
                }

                add(&quot;   xeo_vViewEyeVec = -viewPosition.xyz;&quot;);

                if (normalMapping) {

                    // Transform vertex-&gt;eye vector to tangent space
                    add(&quot;   xeo_vViewEyeVec *= TBN;&quot;);
                }
            }

            if (texturing) {
                add(&quot;   xeo_vUV = xeo_aUV;&quot;);
            }

            if (states.geometry.colors) {
                add(&quot;   xeo_vColor = xeo_aColor;&quot;);
            }

            if (states.geometry.primitiveName === &quot;points&quot;) {
                add(&quot;   gl_PointSize = xeo_uPointSize;&quot;);
            }

            add(&quot;   xeo_vViewPosition = viewPosition;&quot;);

            add(&quot;   gl_Position = xeo_uProjMatrix * viewPosition;&quot;);

            add(&quot;}&quot;);

            return end();
        }


        function fragmentDraw() {

            var fragment = states.shader.fragment;
            if (fragment) {
                // Custom fragment shader
                return fragment;
            }

            var i;
            var len;

            var light;

            begin();

            add(&quot;// Drawing fragment shader&quot;);

            add(&quot;precision &quot; + getFSFloatPrecision(states._canvas.gl) + &quot; float;&quot;);
            add();

            if (normals) {

                add(&quot;varying vec4 xeo_vViewPosition;&quot;);

                add();

                add(&quot;uniform vec3 xeo_uSpecular;&quot;);
                add(&quot;uniform float xeo_uShininess;&quot;);
                add(&quot;uniform float xeo_uReflectivity;&quot;);
            }

            if (normalMapping) {
            //    add(&quot;varying vec3 xeo_vTangent;&quot;);
            }

            add(&quot;uniform vec3 xeo_uEmissive;&quot;);
            add(&quot;uniform float xeo_uOpacity;&quot;);
            add(&quot;uniform vec3 xeo_uDiffuse;&quot;);

            add();

            if (states.geometry.colors) {
                add(&quot;varying vec4 xeo_vColor;&quot;);
            }

            if (texturing) {

                add();
                comment(&quot;Texture variables&quot;);
                add();

                if (states.geometry.uv) {
                    add(&quot;varying vec2 xeo_vUV;&quot;);
                }

                if (states.material.emissiveMap) {
                    add(&quot;uniform sampler2D xeo_uEmissiveMap;&quot;);
                    if (states.material.emissiveMap.matrix) {
                        add(&quot;uniform mat4 xeo_uEmissiveMapMatrix;&quot;);
                    }
                }

                if (states.material.opacityMap) {
                    add(&quot;uniform sampler2D xeo_uOpacityMap;&quot;);
                    if (states.material.opacityMap.matrix) {
                        add(&quot;uniform mat4 xeo_uOpacityMapMatrix;&quot;);
                    }
                }

                if (states.material.ambientMap) {
                    add(&quot;uniform sampler2D xeo_uAmbientMap;&quot;);
                    if (states.material.ambientMap.matrix) {
                        add(&quot;uniform mat4 xeo_uAmbientMapMatrix;&quot;);
                    }
                }

                if (states.material.diffuseMap) {
                    add(&quot;uniform sampler2D xeo_uDiffuseMap;&quot;);
                    if (states.material.diffuseMap.matrix) {
                        add(&quot;uniform mat4 xeo_uDiffuseMapMatrix;&quot;);
                    }
                }

                if (normals) {

                    if (states.material.specularMap) {
                        add(&quot;uniform sampler2D xeo_uSpecularMap;&quot;);
                        if (states.material.specularMap.matrix) {
                            add(&quot;uniform mat4 xeo_uSpecularMapMatrix;&quot;);
                        }
                    }

                    if (states.material.reflectivityMap) {
                        add(&quot;uniform sampler2D xeo_uTextureReflectivity;&quot;);
                        if (states.material.reflectivityMap.matrix) {
                            add(&quot;uniform mat4 xeo_uTextureReflectivityMatrix;&quot;);
                        }
                    }

                    if (normalMapping) {
                        add(&quot;uniform sampler2D xeo_uNormalMap;&quot;);
                        if (states.material.normalMap.matrix) {
                            add(&quot;uniform mat4 xeo_uNormalMapMatrix;&quot;);
                        }
                    }
                }
            }

            add(&quot;uniform vec3 xeo_uLightAmbientColor;&quot;);
            add(&quot;uniform float xeo_uLightAmbientIntensity;&quot;);

            if (normals) {

                // View-space vector from fragment to eye

                add(&quot;varying vec3 xeo_vViewEyeVec;&quot;);

                // View-space fragment normal

                add(&quot;varying vec3 xeo_vViewNormal;&quot;);

                // Light sources

                for (i = 0, len = states.lights.lights.length; i &lt; len; i++) {

                    light = states.lights.lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    add(&quot;uniform vec3 xeo_uLightColor&quot; + i + &quot;;&quot;);
                    add(&quot;uniform float xeo_uLightIntensity&quot; + i + &quot;;&quot;);
                    if (light.type === &quot;point&quot;) {
                        add(&quot;uniform vec3 xeo_uLightAttenuation&quot; + i + &quot;;&quot;);
                    }
                    add(&quot;varying vec4 xeo_vViewLightVecAndDist&quot; + i + &quot;;&quot;);         // Vector from light to vertex
                }

                if (diffuseFresnel || specularFresnel || opacityFresnel || emissiveFresnel || reflectivityFresnel) {

                    add();
                    comment(&quot;Fresnel variables&quot;);
                    add();

                    if (diffuseFresnel) {
                        add(&quot;uniform float xeo_uDiffuseFresnelCenterBias;&quot;);
                        add(&quot;uniform float xeo_uDiffuseFresnelEdgeBias;&quot;);
                        add(&quot;uniform float xeo_uDiffuseFresnelPower;&quot;);
                        add(&quot;uniform vec3 xeo_uDiffuseFresnelCenterColor;&quot;);
                        add(&quot;uniform vec3 xeo_uDiffuseFresnelEdgeColor;&quot;);
                        add();
                    }

                    if (specularFresnel) {
                        add(&quot;uniform float xeo_uSpecularFresnelCenterBias;&quot;);
                        add(&quot;uniform float xeo_uSpecularFresnelEdgeBias;&quot;);
                        add(&quot;uniform float xeo_uSpecularFresnelPower;&quot;);
                        add(&quot;uniform vec3 xeo_uSpecularFresnelCenterColor;&quot;);
                        add(&quot;uniform vec3 xeo_uSpecularFresnelEdgeColor;&quot;);
                        add();
                    }

                    if (opacityFresnel) {
                        add(&quot;uniform float xeo_uOpacityFresnelCenterBias;&quot;);
                        add(&quot;uniform float xeo_uOpacityFresnelEdgeBias;&quot;);
                        add(&quot;uniform float xeo_uOpacityFresnelPower;&quot;);
                        add(&quot;uniform vec3 xeo_uOpacityFresnelCenterColor;&quot;);
                        add(&quot;uniform vec3 xeo_uOpacityFresnelEdgeColor;&quot;);
                        add();
                    }

                    if (reflectivityFresnel) {
                        add(&quot;uniform float xeo_uReflectivityFresnelCenterBias;&quot;);
                        add(&quot;uniform float xeo_uReflectivityFresnelEdgeBias;&quot;);
                        add(&quot;uniform float xeo_uReflectivityFresnelPower;&quot;);
                        add(&quot;uniform vec3 xeo_uReflectivityFresnelCenterColor;&quot;);
                        add(&quot;uniform vec3 xeo_uReflectivityFresnelEdgeColor;&quot;);
                        add();
                    }

                    if (emissiveFresnel) {
                        add(&quot;uniform float xeo_uEmissiveFresnelCenterBias;&quot;);
                        add(&quot;uniform float xeo_uEmissiveFresnelEdgeBias;&quot;);
                        add(&quot;uniform float xeo_uEmissiveFresnelPower;&quot;);
                        add(&quot;uniform vec3 xeo_uEmissiveFresnelCenterColor;&quot;);
                        add(&quot;uniform vec3 xeo_uEmissiveFresnelEdgeColor;&quot;);
                        add();
                    }

                    comment(&quot;Fresnel calculation&quot;);
                    add();
                    add(&quot;float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {&quot;);
                    add(&quot;    float fr = abs(dot(eyeDir, normal));&quot;);
                    add(&quot;    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);&quot;);
                    add(&quot;    return pow(finalFr, power);&quot;);
                    add(&quot;}&quot;);
                }
            }

            add();

            add(&quot;void main(void) {&quot;);

            add();

            add(&quot;   vec3 ambient = xeo_uLightAmbientColor;&quot;);
            add(&quot;   vec3 emissive = xeo_uEmissive;&quot;);
            add(&quot;   float opacity = xeo_uOpacity;&quot;);

            if (states.geometry.colors) {
                add(&quot;   vec3 diffuse = xeo_vColor.rgb;&quot;); // Diffuse color from vertex colors
            } else {
                add(&quot;   vec3 diffuse = xeo_uDiffuse;&quot;);
            }

            if (normals) {

                add(&quot;vec3 viewEyeVec = normalize(xeo_vViewEyeVec);&quot;);

                add(&quot;   vec3 specular = xeo_uSpecular;&quot;);
                add(&quot;   float shininess = xeo_uShininess;&quot;);
                add(&quot;   float reflectivity = xeo_uReflectivity;&quot;);

                if (normalMapping) {

                    add(&quot;   vec3 viewNormal = vec3(0.0, 1.0, 0.0);&quot;);

                } else {

                    // Normalize the interpolated normals in the per-fragment-fragment-shader,
                    // because if we linear interpolated two nonparallel normalized vectors,
                    // the resulting vector won’t be of length 1

                    add(&quot;   vec3 viewNormal = normalize(xeo_vViewNormal);&quot;);
                }
            }

            if (texturing) {

                // Apply textures

                add();
                comment(&quot;   Apply textures&quot;);
                add();

                add(&quot;   vec4 texturePos = vec4(xeo_vUV.s, xeo_vUV.t, 1.0, 1.0);&quot;);
                add(&quot;   vec2 textureCoord;&quot;);

                var material = states.material;

                // Opacity and emissive lighting and mapping are independent of normals

                if (material.emissiveMap) {
                    add();
                    if (material.emissiveMap.matrix) {
                        add(&quot;   textureCoord = (xeo_uEmissiveMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;   textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;   textureCoord.y = -textureCoord.y;&quot;);
                    add(&quot;   emissive = texture2D(xeo_uEmissiveMap, textureCoord).rgb;&quot;);
                }

                if (material.opacityMap) {
                    add();
                    if (material.opacityMap.matrix) {
                        add(&quot;   textureCoord = (xeo_uOpacityMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;   textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;   textureCoord.y = -textureCoord.y;&quot;);
                    add(&quot;   opacity = texture2D(xeo_uOpacityMap, textureCoord).b;&quot;);
                }

                if (material.ambientMap) {
                    add();
                    if (material.ambientMap.matrix) {
                        add(&quot;   textureCoord = (xeo_uAmbientMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;   textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;   textureCoord.y = -textureCoord.y;&quot;);
                    add(&quot;   ambient = texture2D(xeo_uAmbientMap, textureCoord).rgb;&quot;);
                }

                if (material.diffuseMap) {
                    add();
                    if (material.diffuseMap.matrix) {
                        add(&quot;   textureCoord = (xeo_uDiffuseMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;   textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;   textureCoord.y = -textureCoord.y;&quot;);
                    add(&quot;   diffuse = texture2D(xeo_uDiffuseMap, textureCoord).rgb;&quot;);
                }

                if (normals) {

                    if (material.specularMap) {
                        add();
                        if (material.specularMap.matrix) {
                            add(&quot;   textureCoord = (xeo_uSpecularMapMatrix * texturePos).xy;&quot;);
                        } else {
                            add(&quot;   textureCoord = texturePos.xy;&quot;);
                        }
                        add(&quot;   textureCoord.y = -textureCoord.y;&quot;);
                        add(&quot;   specular = texture2D(xeo_uSpecularMap, textureCoord).rgb;&quot;);
                    }

                    if (material.reflectivityMap) {
                        add();
                        if (material.reflectivityMap.matrix) {
                            add(&quot;   textureCoord = (xeo_uReflectivityMapMatrix * texturePos).xy;&quot;);
                        } else {
                            add(&quot;   textureCoord = texturePos.xy;&quot;);
                        }
                        add(&quot;   textureCoord.y = -textureCoord.y;&quot;);
                        add(&quot;   reflectivity = texture2D(xeo_uReflectivityMap, textureCoord).b;&quot;);
                    }
                }

                if (normalMapping) {
                    add();
                    if (material.normalMap.matrix) {
                        add(&quot;   textureCoord = (xeo_uNormalMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;   textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;   textureCoord.y = -textureCoord.y;&quot;);
                    add(&quot;   viewNormal = normalize(texture2D(xeo_uNormalMap, vec2(textureCoord.x, textureCoord.y)).xyz * 2.0 - 1.0);&quot;);
                }
            }

            add(&quot;   vec4 fragColor;&quot;);

            if (normals) {

                // Get Lambertian shading terms

                add();
                add(&quot;   vec3  diffuseLight = vec3(0.0, 0.0, 0.0);&quot;);
                add(&quot;   vec3  specularLight = vec3(0.0, 0.0, 0.0);&quot;);

                add();
                add(&quot;   vec3  viewLightVec;&quot;);
                add(&quot;   float specAngle;&quot;);
                add(&quot;   float lightDist;&quot;);
                add(&quot;   float attenuation;&quot;);


                for (i = 0, len = states.lights.lights.length; i &lt; len; i++) {

                    light = states.lights.lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    // If normal mapping, the fragment-&gt;light vector will be in tangent space
                    add(&quot;   viewLightVec = normalize(xeo_vViewLightVecAndDist&quot; + i + &quot;.xyz);&quot;);


                    if (light.type === &quot;point&quot;) {
                        add();

                        add(&quot;   specAngle = max(dot(viewNormal, viewLightVec), 0.0);&quot;);

                        add(&quot;   lightDist = xeo_vViewLightVecAndDist&quot; + i + &quot;.w;&quot;);

                        add(&quot;   attenuation = 1.0 - (&quot; +
                            &quot;  xeo_uLightAttenuation&quot; + i + &quot;[0] + &quot; +
                            &quot;  xeo_uLightAttenuation&quot; + i + &quot;[1] * lightDist + &quot; +
                            &quot;  xeo_uLightAttenuation&quot; + i + &quot;[2] * lightDist * lightDist);&quot;);

                        add(&quot;   diffuseLight += xeo_uLightIntensity&quot; + i + &quot; * specAngle * xeo_uLightColor&quot; + i + &quot; * attenuation;&quot;);

                        add(&quot;   specularLight += xeo_uLightIntensity&quot; + i + &quot; *  pow(max(dot(reflect(-viewLightVec, -viewNormal), viewEyeVec), 0.0), shininess) * attenuation;&quot;);
                    }

                    if (light.type === &quot;dir&quot;) {

                        add(&quot;   specAngle = max(dot(viewNormal, -viewLightVec), 0.0);&quot;);

                        add(&quot;   diffuseLight += xeo_uLightIntensity&quot; + i + &quot; * specAngle * xeo_uLightColor&quot; + i + &quot;;&quot;);

                        add(&quot;   specularLight += xeo_uLightIntensity&quot; + i + &quot; * pow(max(dot(reflect(viewLightVec, -viewNormal), viewEyeVec), 0.0), shininess);&quot;);
                    }
                }

                add();

                // Get Fresnel terms

                if (diffuseFresnel || specularFresnel || opacityFresnel || emissiveFresnel || reflectivityFresnel) {

                    add();
                    comment(&quot;   Apply Fresnels&quot;);

                    if (diffuseFresnel) {
                        add();
                        add(&quot;float diffuseFresnel = fresnel(viewEyeVec, viewNormal, xeo_uDiffuseFresnelEdgeBias, xeo_uDiffuseFresnelCenterBias, xeo_uDiffuseFresnelPower);&quot;);
                        add(&quot;diffuse *= mix(xeo_uDiffuseFresnelEdgeColor, xeo_uDiffuseFresnelCenterColor, diffuseFresnel);&quot;);
                    }

                    if (specularFresnel) {
                        add();
                        add(&quot;float specularFresnel = fresnel(viewEyeVec, viewNormal, xeo_uSpecularFresnelEdgeBias, xeo_uSpecularFresnelCenterBias, xeo_uSpecularFresnelPower);&quot;);
                        add(&quot;specular *= mix(xeo_uSpecularFresnelEdgeColor, xeo_uSpecularFresnelCenterColor, specularFresnel);&quot;);
                    }

                    if (opacityFresnel) {
                        add();
                        add(&quot;float opacityFresnel = fresnel(viewEyeVec, viewNormal, xeo_uOpacityFresnelEdgeBias, xeo_uOpacityFresnelCenterBias, xeo_uOpacityFresnelPower);&quot;);
                        add(&quot;opacity *= mix(xeo_uOpacityFresnelEdgeColor.r, xeo_uOpacityFresnelCenterColor.r, opacityFresnel);&quot;);
                    }

                    if (emissiveFresnel) {
                        add();
                        add(&quot;float emissiveFresnel = fresnel(viewEyeVec, viewNormal, xeo_uEmissiveFresnelEdgeBias, xeo_uEmissiveFresnelCenterBias, xeo_uEmissiveFresnelPower);&quot;);
                        add(&quot;emissive *= mix(xeo_uEmissiveFresnelEdgeColor, xeo_uEmissiveFresnelCenterColor, emissiveFresnel);&quot;);
                    }
                }

                // Combine terms with Blinn-Phong BRDF

                add();
                comment(&quot;   Phong BRDF&quot;);
                add();
                add(&quot;   fragColor = vec4((specular * specularLight) + ((diffuseLight + (ambient * xeo_uLightAmbientIntensity) ) * diffuse) + emissive, opacity);&quot;);

            } else {

                // No normals
                add();
                comment(&quot;   Non-Lambertian BRDF&quot;);
                add();
                add(&quot;   fragColor = vec4(emissive + diffuse, opacity);&quot;);
            }

            add(&quot;   fragColor.rgb *= fragColor.a;&quot;);

            add(&quot;   gl_FragColor = fragColor;&quot;);

            add(&quot;}&quot;);

            return end();
        }

        // Start fresh program source
        function begin() {
            src = [];
        }

        // Append to program source
        function add(txt) {
            src.push(txt || &quot;&quot;);
        }

        // Append to program source
        function comment(txt) {
            if (txt) {
                var c = 0;
                for (var i = 0, len = txt.length; i &lt; len; i++) {
                    if (txt.charAt(i) === &quot; &quot;) {
                        c++;
                    }
                }
                var pad = c &gt; 0 ? txt.substring(0, c - 1) : &quot;&quot;;
                src.push(pad + &quot;// &quot; + txt.substring(c - 1));
            }
        }

        // Finish building program source
        function end() {
            return src;
        }

        function getFSFloatPrecision(gl) {

            if (!gl.getShaderPrecisionFormat) {
                return &quot;mediump&quot;;
            }

            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision &gt; 0) {
                return &quot;highp&quot;;
            }

            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision &gt; 0) {
                return &quot;mediump&quot;;
            }

            return &quot;lowp&quot;;
        }

    })();

})();
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
